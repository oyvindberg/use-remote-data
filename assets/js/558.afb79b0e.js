"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[558],{558:(e,t,i)=>{i.d(t,{Mf:()=>d,Qt:()=>c,nS:()=>g,mp:()=>y,$o:()=>w});var n=i(4848);const r=({storeName:e,errors:t,retry:i})=>{const r=e?(0,n.jsxs)("strong",{children:["Failed request for store ",e]}):(0,n.jsx)("strong",{children:"Failed request"}),a=t.map(((e,t)=>e instanceof Error?(0,n.jsxs)("div",{children:[(0,n.jsxs)("span",{children:[e.name,": ",e.message]}),(0,n.jsx)("pre",{children:(0,n.jsx)("code",{children:e.stack})})]},t):(0,n.jsx)("div",{children:(0,n.jsx)("pre",{children:(0,n.jsx)("code",{children:JSON.stringify(e)})})},t)));return(0,n.jsxs)("div",{children:[r,a,(0,n.jsx)("button",{onClick:i,children:"retry"})]})},a=()=>(0,n.jsx)("div",{children:"..."});var s,d;!function(e){e.Valid={type:"valid"},e.Invalid={type:"invalid"},e.RefetchAfter=(e,t)=>({type:"retry-in",current:e,millis:t})}(s||(s={})),function(e){e.of=e=>({decide:e}),e.alwaysValid=()=>e.of((()=>s.Valid)),e.pollUntil=(t,i)=>e.of(((e,n,r)=>{if(t(e))return s.Valid;const a=Math.max(n.getTime()+i-r.getTime(),1);return s.RefetchAfter(s.Invalid,a)})),e.refetchAfterMillis=t=>e.of(((e,i,n)=>{const r=i.getTime()+t-n.getTime();return r<=0?s.Invalid:s.RefetchAfter(s.Valid,r+1)}))}(d||(d={}));const l=e=>null!=e;var o,u;!function(e){e.Initial={type:"initial"},e.Pending={type:"pending"},e.No=(e,t)=>({type:"no",errors:e,retry:t}),e.Yes=e=>({type:"yes",value:e}),e.InvalidatedInitial=e=>({type:"invalidated-initial",invalidated:e}),e.InvalidatedPending=e=>({type:"invalidated-pending",invalidated:e}),e.all=(...t)=>{const i=[];let n,r,a=!1,s=[];for(const e of t)switch(e.type){case"yes":i.push(e.value);break;case"invalidated-initial":case"invalidated-pending":a=!0,i.push(e.invalidated.value);break;case"initial":r=e;break;case"no":s.push(e);break;case"pending":n=e}if(s.length>0){const t=()=>Promise.all(s.map((e=>e.retry()))).then((()=>{})),i=s.reduce(((e,t)=>[...e,...t.errors]),[]);return e.No(i,t)}if(l(n))return n;if(l(r))return r;const d=e.Yes(i);return a?e.InvalidatedPending(d):d},e.orNull=t=>e.fold(t)((e=>e),(()=>null),(e=>null)),e.fold=e=>(t,i,n)=>{switch(e.type){case"initial":case"pending":return i();case"yes":return t(e.value,!1);case"no":return n(e.errors,e.retry);case"invalidated-initial":case"invalidated-pending":return t(e.invalidated.value,!0)}},e.pendingStateFor=t=>{switch(t.type){case"invalidated-initial":return e.InvalidatedPending(t.invalidated);case"yes":return e.InvalidatedPending(t);default:return e.Pending}},e.initialStateFor=t=>"yes"===t.type?e.InvalidatedInitial(t):e.Initial,e.map=(t,i)=>{switch(t.type){case"initial":return e.Initial;case"pending":return e.Pending;case"no":return e.No(t.errors,t.retry);case"yes":return e.Yes(i(t.value));case"invalidated-initial":return e.InvalidatedInitial(e.Yes(i(t.invalidated.value)));case"invalidated-pending":return e.InvalidatedPending(e.Yes(i(t.invalidated.value)))}}}(o||(o={})),function(e){e.all=e=>{const t=e.filter(l);if(0!==t.length)return()=>t.forEach((e=>e()))}}(u||(u={}));var c,p=function(e,t,i,n,r){if("m"===n)throw new TypeError("Private method is not writable");if("a"===n&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?r.call(e,i):r?r.value=i:t.set(e,i),i},h=function(e,t,i,n){if("a"===i&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===i?n:"a"===i?n.call(e):n?n.value:t.get(e)};!function(e){var t,i,n,r;e.all=(...e)=>new a(e);class a{constructor(e){t.set(this,void 0),this.triggerUpdate=()=>{if("no"!==this.current.type)return u.all(h(this,t,"f").map((e=>e.triggerUpdate())))},this.invalidate=()=>h(this,t,"f").forEach((e=>e.invalidate())),p(this,t,e,"f")}get current(){return o.all(...h(this,t,"f").map((e=>e.current)))}get storeName(){return h(this,t,"f").map((e=>e.storeName)).filter(l).join(", ")}get orNull(){return e.orNull(this)}map(e){return new d(this,e)}}t=new WeakMap,e.orNull=e=>new s(e);class s{constructor(e){i.set(this,void 0),p(this,i,e,"f"),this.triggerUpdate=h(this,i,"f").triggerUpdate,this.invalidate=h(this,i,"f").invalidate}get current(){return o.Yes(o.orNull(h(this,i,"f").current))}get storeName(){return h(this,i,"f").storeName}get orNull(){return new s(this)}map(e){return new d(this,e)}}i=new WeakMap,e.map=(e,t)=>new d(e,t);class d{constructor(e,t){n.set(this,void 0),r.set(this,void 0),p(this,n,e,"f"),p(this,r,t,"f"),this.triggerUpdate=h(this,n,"f").triggerUpdate,this.invalidate=h(this,n,"f").invalidate}get current(){return o.map(h(this,n,"f").current,h(this,r,"f"))}get storeName(){return h(this,n,"f").storeName}get orNull(){return e.orNull(this)}map(e){return new d(this,e)}}n=new WeakMap,r=new WeakMap,e.always=(e,t)=>new c(e,t);class c{constructor(e,t){this.triggerUpdate=()=>{},this.invalidate=()=>{},this.current=e,this.storeName=t}get orNull(){return e.orNull(this)}map(e){return new d(this,e)}}}(c||(c={}));var f,v=i(6540);function g({store:e,children:t,ErrorComponent:i=r,PendingComponent:s=a}){return(0,v.useEffect)(e.triggerUpdate,[e]),o.fold(e.current)(((e,i)=>(0,n.jsx)("div",{children:t(e,i)})),(()=>(0,n.jsx)(s,{})),((t,r)=>(0,n.jsx)(i,{errors:t,retry:r,storeName:e.storeName})))}!function(e){e.of=e=>void 0===e?"undefined":JSON.stringify(e)}(f||(f={}));const m=Number(v.version.split(".")[0]),w=(e,t={})=>{const[i,n]=(0,v.useState)(new Map),[r,a]=(0,v.useState)(new Map),[s,d]=(0,v.useState)(t.dependencies),u=e=>{if(l(t.storeName))return void 0!==e?`${t.storeName}(${e})`:t.storeName};let p=!0;m<18&&(0,v.useEffect)((()=>()=>{t.debug&&t.debug(`${u(void 0)} unmounting`),p=!1}),[]);const h=(e,i,r)=>{p?(t.debug&&t.debug(`${u(e)} => `,i,r),l(r)&&a((t=>{const i=new Map(t);return i.set(e,r),i})),n((t=>{const n=new Map(t);return n.set(e,i),n}))):t.debug&&t.debug(`${u(e)} dropped update because component has been unmounted`,i,r)},g=(t,i,n)=>(h(i,n),e(t).then((e=>h(i,o.Yes(e),new Date))).catch((e=>h(i,o.No([e],(()=>g(t,i,o.Pending))))))),w=new Map,y=e=>{const a=f.of(e);return{storeName:u(a),get current(){return i.get(a)||o.Initial},invalidate:()=>{h(a,o.initialStateFor(i.get(a)||o.Initial))},triggerUpdate:()=>((e,a)=>{if(f.of(s)!==f.of(t.dependencies)){t.debug&&t.debug(`${u(a)} invalidating due to deps, from/to:`,s,t.dependencies),d(t.dependencies);const e=new Map;return i.forEach(((t,i)=>e.set(i,o.initialStateFor(t)))),void n(e)}if(w.get(a))return;w.set(a,!0);const c=i.get(a)||o.Initial;if("initial"===c.type||"invalidated-initial"===c.type)return void g(e,a,o.pendingStateFor(c));const p=r.get(a);if(l(t.invalidation)&&"yes"===c.type&&l(p)){const e=t.invalidation.decide(c.value,p,new Date);switch(e.type){case"invalid":return void h(a,o.InvalidatedInitial(c));case"valid":return;case"retry-in":t.debug&&t.debug(`${u(a)}: will invalidate in ${e.millis}`);const i=setTimeout((()=>h(a,o.InvalidatedInitial(c))),e.millis);return()=>{t.debug&&t.debug(`${u(a)}: cancelled invalidation on unmount`),clearTimeout(i)}}}})(e,a),get orNull(){return c.orNull(this)},map(e){return c.map(this,e)}}};return{get:y,getMany:e=>e.map(y)}},y=(e,t)=>w(e,t).get(void 0)}}]);