(self.webpackChunksite=self.webpackChunksite||[]).push([[217],{250:(e,n,t)=>{var s={"./basic_usage":3172,"./basic_usage.tsx":3172,"./combine":8789,"./combine.tsx":8789,"./create":3832,"./create.tsx":3832,"./dynamic":9641,"./dynamic.tsx":9641,"./handling_failure":2376,"./handling_failure.tsx":2376,"./invalidation":3544,"./invalidation.tsx":3544,"./invalidation_dependencies":1530,"./invalidation_dependencies.tsx":1530,"./invalidation_sometimes":1667,"./invalidation_sometimes.tsx":1667,"./polling":4999,"./polling.tsx":4999,"./use_twice":5550,"./use_twice.tsx":5550};function a(e){var n=i(e);return t(n)}function i(e){if(!t.o(s,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return s[e]}a.keys=function(){return Object.keys(s)},a.resolve=i,e.exports=a,a.id=250},409:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    RemoteDataStore,\n    useRemoteData,\n    WithRemoteData,\n} from 'use-remote-data';\n\nfunction produce<T>(value: T, delay: number = 1000): Promise<T> {\n    return new Promise((resolve) => setTimeout(() => resolve(value), delay));\n}\n\nexport const Component: React.FC = () => {\n    const computeOne = useRemoteData(() => produce(1));\n    const computeString = useRemoteData(() => produce('Hello'));\n\n    const combinedStore = RemoteDataStore.all(computeOne, computeString);\n\n    return (\n        <WithRemoteData store={combinedStore}>\n            {([num, string]) => (\n                <span>\n                    {num} and {string}\n                </span>\n            )}\n        </WithRemoteData>\n    );\n};\n"},809:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"type":"mdx","permalink":"/use-remote-data/intro","source":"@site/src/pages/intro.mdx","title":"Getting Started","description":"use-remote-data is a small library that provides a principled, type-safe way to manage asynchronous state in your React applications.","frontMatter":{},"unlisted":false}');var a=t(4848),i=t(8453),r=t(8794),o=t(7879);const l={},d="Getting Started",c={},h=[{value:"Installation",id:"installation",level:2},{value:"The Core State Machine",id:"the-core-state-machine",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"The <code>&lt;WithRemoteData&gt;</code> Component",id:"the-withremotedata-component",level:3},{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Parallel vs. Sequential Fetching",id:"parallel-vs-sequential-fetching",level:3},{value:"Data Lifetime Aligned with React Components",id:"data-lifetime-aligned-with-react-components",level:3},{value:"Combining Stores",id:"combining-stores",level:2},{value:"A Note on TypeScript Tooling",id:"a-note-on-typescript-tooling",level:4},{value:"Refreshing Data (Invalidation)",id:"refreshing-data-invalidation",level:2},{value:"Only Sometimes?",id:"only-sometimes",level:3},{value:"Sharing Data with Child Components",id:"sharing-data-with-child-components",level:2},{value:"Should I Pass <code>RemoteDataStore&lt;T&gt;</code> or Just <code>T</code>?",id:"should-i-pass-remotedatastoret-or-just-t",level:3},{value:"Handling Failure and Retries",id:"handling-failure-and-retries",level:2},{value:"Polling",id:"polling",level:2},{value:"Dynamic Data",id:"dynamic-data",level:2},{value:"Invalidate on Dependency Change",id:"invalidate-on-dependency-change",level:2},{value:"Updates (Write Operations)",id:"updates-write-operations",level:2},{value:"Conclusion",id:"conclusion",level:2}];function m(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"getting-started",children:"Getting Started"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"use-remote-data"})," is a small library that provides a principled, type-safe way to manage asynchronous state in your React applications.\nIt revolves around a ",(0,a.jsx)(n.strong,{children:"core state machine"})," represented by the ",(0,a.jsx)(n.code,{children:"RemoteData"})," type and a corresponding\n",(0,a.jsx)(n.code,{children:"RemoteDataStore"})," that orchestrates fetching,\ncaching, invalidation,\nand retries\u2014all while staying strongly typed."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm install use-remote-data\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"yarn add use-remote-data\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"the-core-state-machine",children:"The Core State Machine"}),"\n",(0,a.jsxs)(n.p,{children:["At the heart of this library is the ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"RemoteData"})})," type.\nIt captures all possible states of an async request in a single union:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"export type RemoteData<T> =\n    | { type: 'initial' }\n    | { type: 'pending' }\n    | { type: 'no'; errors: ReadonlyArray<Error | unknown>; retry: () => Promise<void> }\n    | { type: 'yes'; value: T }\n    | { type: 'invalidated-initial'; invalidated: T }\n    | { type: 'invalidated-pending'; invalidated: T };\n"})}),"\n",(0,a.jsx)(n.p,{children:"This state machine allows the library to cleanly handle the life cycle of any request:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"initial"})}),": We haven\u2019t started fetching yet (lazy load)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"pending"})}),": A request is ongoing (fetch in progress)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"no"})}),": The request failed (includes errors and a retry callback)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"yes"})}),": The request succeeded (includes the fetched value)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"invalidated-initial"})}),": We have stale data but haven\u2019t started fetching."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"invalidated-pending"})}),": We have stale data and are fetching an update."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"By modeling states explicitly, React components can branch on them in a straightforward and type-safe manner."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsxs)(n.p,{children:["The primary entry point is the ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRemoteData"})})," hook.\nIt takes one parameter\u2014a function that produces a ",(0,a.jsx)(n.code,{children:"Promise"}),"\u2014and returns a ",(0,a.jsx)(n.code,{children:"RemoteDataStore<T>"}),".\nBecause we need the ability to retry, you must pass a function rather than a direct ",(0,a.jsx)(n.code,{children:"Promise"}),"."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["According to ",(0,a.jsx)(n.a,{href:"https://reactjs.org/docs/hooks-rules.html",children:"React Hooks rules"}),", the hook must be used inside a component."]}),"\n",(0,a.jsxs)(n.li,{children:["The object returned by ",(0,a.jsx)(n.code,{children:"useRemoteData"})," is our ",(0,a.jsx)(n.code,{children:"RemoteDataStore<T>"}),"."]}),"\n"]}),"\n",(0,a.jsx)(r.Y,{snippet:"basic_usage"}),"\n",(0,a.jsxs)(n.h3,{id:"the-withremotedata-component",children:["The ",(0,a.jsx)(n.code,{children:"<WithRemoteData>"})," Component"]}),"\n",(0,a.jsxs)(n.p,{children:["The library provides a small helper component called ",(0,a.jsx)(n.code,{children:"WithRemoteData"})," for convenience. It expects two props:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"store"})}),": The ",(0,a.jsx)(n.code,{children:"RemoteDataStore"})," returned by ",(0,a.jsx)(n.code,{children:"useRemoteData"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"render"})}),": A ",(0,a.jsx)(n.a,{href:"https://reactjs.org/docs/render-props.html",children:"render prop"})," that receives your successfully loaded data (along with an ",(0,a.jsx)(n.code,{children:"isInvalidated"})," boolean)."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Out of the box, ",(0,a.jsx)(n.code,{children:"WithRemoteData"})," handles loading and error states but is visually minimal.\nYou can copy it directly into your codebase\nor wrap it to provide custom styling and behavior for pending and failure states."]}),"\n",(0,a.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,a.jsxs)(n.p,{children:["An interesting aspect of ",(0,a.jsx)(n.code,{children:"useRemoteData"})," is no data is fetched when you call ",(0,a.jsx)(n.code,{children:"useRemoteData"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Only when the data is rendered with ",(0,a.jsx)(n.code,{children:"WithRemoteData"})," is the request initiated.\nThis is handy, because then you can initialize many ",(0,a.jsx)(n.code,{children:"RemoteDataStore"}),"s in a component high up in the hierarchy, and pass them down to children."]}),"\n",(0,a.jsx)(n.h3,{id:"parallel-vs-sequential-fetching",children:"Parallel vs. Sequential Fetching"}),"\n",(0,a.jsxs)(n.p,{children:["When your app renders data from multiple ",(0,a.jsx)(n.code,{children:"RemoteDataStore"})," instances, they will initiate their requests in parallel if the data is missing or old."]}),"\n",(0,a.jsx)(n.p,{children:"This parallel behavior ensures quicker overall loading times when you need multiple pieces of data at once."}),"\n",(0,a.jsxs)(n.p,{children:["If you need to fetch data in a specific order, you can achieve this by nesting ",(0,a.jsx)(n.code,{children:"WithData"})," inside ",(0,a.jsx)(n.code,{children:"WithData"})," in your JSX,\nmeaning that the inner won't be rendered/requested until the outer has finished."]}),"\n",(0,a.jsx)(n.h3,{id:"data-lifetime-aligned-with-react-components",children:"Data Lifetime Aligned with React Components"}),"\n",(0,a.jsx)(n.p,{children:"Because each store is created by the hook in a mounted component, data only exists as long as that component is active.\nThere\u2019s no global state or context\u2014once the component unmounts, the store is effectively garbage-collected.\nThis design ensures data is retained only while it\u2019s relevant."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"combining-stores",children:"Combining Stores"}),"\n",(0,a.jsxs)(n.p,{children:["One of the library\u2019s most powerful patterns is combining multiple requests.\nIf you have two or more ",(0,a.jsx)(n.code,{children:"RemoteDataStore"}),"s,\nyou can merge them into a single store that represents all requests in flight.\nThis is done via ",(0,a.jsx)(n.code,{children:"RemoteDataStore.all(...)"}),":"]}),"\n",(0,a.jsxs)(n.p,{children:["Under the hood, the combined store uses the ",(0,a.jsx)(n.code,{children:"RemoteData.all(...)"})," function, which:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Returns ",(0,a.jsx)(n.code,{children:"No"})," if ",(0,a.jsx)(n.em,{children:"any"})," store fails. A single \u201cretry\u201d will only re-fetch the failing requests."]}),"\n",(0,a.jsxs)(n.li,{children:["Returns ",(0,a.jsx)(n.code,{children:"Pending"})," if ",(0,a.jsx)(n.em,{children:"any"})," constituent store is ",(0,a.jsx)(n.code,{children:"Pending"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Returns ",(0,a.jsx)(n.code,{children:"Yes"})," with a tuple of all combined values if ",(0,a.jsx)(n.em,{children:"all"})," succeed."]}),"\n",(0,a.jsx)(n.li,{children:"Manages invalidation states if any store becomes invalidated."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In a render prop, you can\n",(0,a.jsx)(n.a,{href:"https://levelup.gitconnected.com/crazy-powerful-typescript-tuple-types-9b121e0a690c",children:"destructure"}),"\nthe results."]}),"\n",(0,a.jsx)(r.Y,{snippet:"combine"}),"\n",(0,a.jsx)(n.h4,{id:"a-note-on-typescript-tooling",children:"A Note on TypeScript Tooling"}),"\n",(0,a.jsxs)(n.p,{children:["The TypeScript compiler (and IDEs) fully understands these combined stores.\nYou can hover over the tuple items (often with ",(0,a.jsx)("kbd",{children:"Ctrl"})," or ",(0,a.jsx)("kbd",{children:"Command"}),") to see precise type information."]}),"\n",(0,a.jsx)("video",{autoPlay:!0,controls:!0,muted:!0,style:{maxWidth:"100%"},src:o.A}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"refreshing-data-invalidation",children:"Refreshing Data (Invalidation)"}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes data becomes out-of-date.\nsupports \u201cinvalidation\u201d through an optional ",(0,a.jsx)(n.code,{children:"invalidation"})," parameter on the hook.\nAn ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"InvalidationStrategy<T>"})})," is a small object that decides whether to keep data or mark it stale.\nFor example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"{\n    invalidation: InvalidationStrategy.refetchAfterMillis(10_000);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If the data is older than 10 seconds, the store automatically transitions into one of the ",(0,a.jsx)(n.code,{children:"invalidated-*"})," states.\nIn the ",(0,a.jsx)(n.code,{children:"<WithRemoteData>"})," render prop,\nyou can check the second argument (",(0,a.jsx)(n.code,{children:"isInvalidated"}),")\nto decide whether to let the user see old data or a loading indicator."]}),"\n",(0,a.jsx)(r.Y,{snippet:"invalidation"}),"\n",(0,a.jsx)(n.h3,{id:"only-sometimes",children:"Only Sometimes?"}),"\n",(0,a.jsxs)(n.p,{children:["You can enable or disable invalidation dynamically by swapping the ",(0,a.jsx)(n.code,{children:"invalidation"})," strategy in or out. For instance:"]}),"\n",(0,a.jsx)(r.Y,{snippet:"invalidation_sometimes"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"sharing-data-with-child-components",children:"Sharing Data with Child Components"}),"\n",(0,a.jsx)(n.p,{children:"A common pattern is to fetch data high in your component tree and share it among multiple routes or components,\nleveraging built-in caching so that each route doesn\u2019t refetch unnecessarily."}),"\n",(0,a.jsxs)(n.p,{children:["Since ",(0,a.jsx)(n.code,{children:"RemoteDataStore"})," is both ",(0,a.jsx)(n.em,{children:"lazy"})," and ",(0,a.jsx)(n.em,{children:"caching"}),", you can pass the same store to multiple children.\nData is fetched only once, and the results remain in memory as long as a store is in use."]}),"\n",(0,a.jsx)(r.Y,{snippet:"use_twice"}),"\n",(0,a.jsxs)(n.h3,{id:"should-i-pass-remotedatastoret-or-just-t",children:["Should I Pass ",(0,a.jsx)(n.code,{children:"RemoteDataStore<T>"})," or Just ",(0,a.jsx)(n.code,{children:"T"}),"?"]}),"\n",(0,a.jsx)(n.p,{children:"There\u2019s a subtle difference:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Does the child component need to render anything while data is still loading?"})}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["If yes, consider passing a ",(0,a.jsx)(n.code,{children:"RemoteDataStore<T>"})," so the child can handle loading/failure states."]}),"\n",(0,a.jsxs)(n.li,{children:["Otherwise, if the parent already handles loading and passes down final data, just pass ",(0,a.jsx)(n.code,{children:"T"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"handling-failure-and-retries",children:"Handling Failure and Retries"}),"\n",(0,a.jsxs)(n.p,{children:["Another defining feature of ",(0,a.jsx)(n.code,{children:"use-remote-data"})," is the principled error handling and the retry\nfunctionality.\nDevelopers typically make an ad-hoc attempt at the former, while not many have the\ndiscipline to also do the latter."]}),"\n",(0,a.jsxs)(n.p,{children:["This example creates a ",(0,a.jsx)(n.code,{children:"Promise"})," which fails every tenth time it is called.\nThe sometimes-failing store is combined with another store which never fails,\nand you should hit ",(0,a.jsx)(n.em,{children:"retry"})," a few times to see the interaction."]}),"\n",(0,a.jsx)(r.Y,{snippet:"handling_failure"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"polling",children:"Polling"}),"\n",(0,a.jsxs)(n.p,{children:["Something which comes up sometimes are APIs which require you to poll.\n",(0,a.jsx)(n.code,{children:"use-remote-data"})," supports this through an ",(0,a.jsx)(n.code,{children:"InvalidationStrategy"})," like seen above"]}),"\n",(0,a.jsx)(r.Y,{snippet:"polling"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"dynamic-data",children:"Dynamic Data"}),"\n",(0,a.jsxs)(n.p,{children:["If you need parameterized requests\u2014like paginated lists\nor fetching multiple resource IDs\u2014use the ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRemoteDatas"})})," (plural) hook.\nIt returns an object with a ",(0,a.jsx)(n.code,{children:".get(key)"})," method for each distinct data slice."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"const itemsStore = useRemoteDatas((page: number) => fetch(`/api/items?page=${page}`).then((res) => res.json()));\n\nconst firstPageStore = itemsStore.get(1);\nconst secondPageStore = itemsStore.get(2);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This creates independent ",(0,a.jsx)(n.code,{children:"RemoteDataStore"})," objects for each page, all managed under one ",(0,a.jsx)(n.code,{children:"RemoteDataStores"})," instance."]}),"\n",(0,a.jsx)(r.Y,{snippet:"dynamic"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"invalidate-on-dependency-change",children:"Invalidate on Dependency Change"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useRemoteData"})," and ",(0,a.jsx)(n.code,{children:"useRemoteDatas"})," let you provide a ",(0,a.jsx)(n.code,{children:"dependencies"})," array (similar to React\u2019s ",(0,a.jsx)(n.code,{children:"useEffect"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"useRemoteData(() => fetchData(), {\n    dependencies: [props.userId, otherValue],\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When the dependency array changes, the store invalidates automatically, and ",(0,a.jsx)(n.code,{children:"triggerUpdate()"})," will re-fetch if needed.\n(Currently, it compares dependencies by ",(0,a.jsx)(n.code,{children:"JSON.stringify"}),".)"]}),"\n",(0,a.jsx)(r.Y,{snippet:"invalidation_dependencies"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"updates-write-operations",children:"Updates (Write Operations)"}),"\n",(0,a.jsxs)(n.p,{children:["Your application might need to send data back to the server.\nWhile ",(0,a.jsx)(n.code,{children:"use-remote-data"})," focuses on read operations,\nyou can still integrate writes by calling out to the server in your components.\nAfter a successful write,\ncall ",(0,a.jsx)(n.code,{children:"invalidate()"})," or ",(0,a.jsx)(n.code,{children:"triggerUpdate()"})," to refresh any store that depends on the changed data."]}),"\n",(0,a.jsx)(r.Y,{snippet:"create"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"use-remote-data"})," provides a comprehensive, type-safe approach to async state management in React.\nIt builds on a clear state machine (",(0,a.jsx)(n.code,{children:"RemoteData"}),"), robust invalidation (",(0,a.jsx)(n.code,{children:"InvalidationStrategy"}),"), and fully typed store composition."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},1180:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    InvalidationStrategy,\n    useRemoteData,\n    WithRemoteData,\n} from 'use-remote-data';\n\nvar i = 0;\nconst freshData = (): Promise<number> =>\n    new Promise((resolve) => {\n        i += 1;\n        setTimeout(() => resolve(i), 1000);\n    });\n\nexport const Component: React.FC = () => {\n    const store = useRemoteData(freshData, {\n        invalidation: InvalidationStrategy.refetchAfterMillis(2000),\n    });\n\n    return (\n        <WithRemoteData store={store}>\n            {(num, isInvalidated) => (\n                <span style={{ color: isInvalidated ? 'darkgray' : 'black' }}>\n                    {num}\n                </span>\n            )}\n        </WithRemoteData>\n    );\n};\n"},1266:(e,n,t)=>{var s={"./basic_usage.tsx":8936,"./combine.tsx":409,"./create.tsx":2556,"./dynamic.tsx":5525,"./handling_failure.tsx":5588,"./invalidation.tsx":1180,"./invalidation_dependencies.tsx":2542,"./invalidation_sometimes.tsx":9439,"./polling.tsx":5107,"./use_twice.tsx":5170};function a(e){var n=i(e);return t(n)}function i(e){if(!t.o(s,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return s[e]}a.keys=function(){return Object.keys(s)},a.resolve=i,e.exports=a,a.id=1266},1530:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>l});var s=t(6540),a=t(558),i=t(4848),r=0;const o=()=>new Promise((e=>{r+=1,setTimeout((()=>e(r)),1e3)})),l=()=>{const[e,n]=s.useState(1),t=(0,a.mp)(o,{dependencies:[e]});return(0,i.jsxs)("div",{children:[(0,i.jsx)("button",{onClick:()=>n(e+1),children:"Bump dep"}),(0,i.jsx)("br",{}),(0,i.jsx)(a.nS,{store:t,children:(e,n)=>(0,i.jsx)("span",{style:{color:n?"darkgray":"black"},children:e})})]})}},1667:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>l});var s=t(6540),a=t(558),i=t(4848),r=0;const o=()=>new Promise((e=>{r+=1,setTimeout((()=>e(r)),1e3)})),l=()=>{const[e,n]=s.useState(!0),t=(0,a.mp)(o,{invalidation:e?a.Mf.refetchAfterMillis(1e3):void 0});return(0,i.jsxs)("div",{children:[(0,i.jsxs)("label",{children:["Autorefresh:",(0,i.jsx)("input",{type:"checkbox",onChange:t=>n(!e),checked:e})]}),(0,i.jsx)("br",{}),(0,i.jsx)(a.nS,{store:t,children:(e,n)=>(0,i.jsx)("span",{style:{color:n?"darkgray":"black"},children:e})})]})}},2376:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>d});t(6540);var s=t(558),a=t(4848),i=0;const r=()=>new Promise((e=>{i+=1,setTimeout((()=>e(i)),1e3)}));var o=0;const l=()=>new Promise(((e,n)=>{(o+=1)%10==0?n(`${o} was dividable by 10`):e(o)})),d=()=>{const e=(0,s.mp)(r,{invalidation:s.Mf.refetchAfterMillis(1e3)}),n=(0,s.mp)(l,{invalidation:s.Mf.refetchAfterMillis(100)});return(0,a.jsx)(s.nS,{store:s.Qt.all(e,n),children:e=>{let[n,t]=e;return(0,a.jsxs)("span",{children:[n," - ",t]})}})}},2542:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport { useRemoteData, WithRemoteData } from 'use-remote-data';\n\nvar i = 0;\nconst freshData = (): Promise<number> =>\n    new Promise((resolve) => {\n        i += 1;\n        setTimeout(() => resolve(i), 1000);\n    });\n\nexport const Component: React.FC = () => {\n    const [dep, setDep] = React.useState(1);\n    const store = useRemoteData(freshData, { dependencies: [dep] });\n\n    return (\n        <div>\n            <button onClick={() => setDep(dep + 1)}>Bump dep</button>\n            <br />\n            <WithRemoteData store={store}>\n                {(num, isInvalidated) => (\n                    <span\n                        style={{ color: isInvalidated ? 'darkgray' : 'black' }}\n                    >\n                        {num}\n                    </span>\n                )}\n            </WithRemoteData>\n        </div>\n    );\n};\n"},2556:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport { useRemoteData, WithRemoteData } from 'use-remote-data';\n\nconst createUser = (name: string): Promise<string> =>\n    new Promise((resolve) => {\n        setTimeout(\n            () => resolve(`created user with name ${name} and id #1`),\n            1000\n        );\n    });\n\nexport const Component: React.FC = () => {\n    const [name, setName] = React.useState('');\n    const [submit, setSubmit] = React.useState(false);\n    const createUserStore = useRemoteData(() => createUser(name));\n\n    return (\n        <div>\n            <h4>Create user</h4>\n            <label>\n                name:\n                <input\n                    onChange={(e) => setName(e.currentTarget.value)}\n                    value={name}\n                />\n            </label>\n            <button onClick={() => setSubmit(true)}>Create user</button>\n            {submit && (\n                <WithRemoteData store={createUserStore}>\n                    {(msg) => <p>{msg}</p>}\n                </WithRemoteData>\n            )}\n        </div>\n    );\n};\n"},3172:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>i});t(6540);var s=t(558),a=t(4848);const i=()=>{const e=(0,s.mp)((()=>{return e=1,void 0===n&&(n=1e3),new Promise((t=>setTimeout((()=>t(e)),n)));var e,n}));return(0,a.jsx)(s.nS,{store:e,children:e=>(0,a.jsx)("span",{children:e})})}},3544:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>o});t(6540);var s=t(558),a=t(4848),i=0;const r=()=>new Promise((e=>{i+=1,setTimeout((()=>e(i)),1e3)})),o=()=>{const e=(0,s.mp)(r,{invalidation:s.Mf.refetchAfterMillis(2e3)});return(0,a.jsx)(s.nS,{store:e,children:(e,n)=>(0,a.jsx)("span",{style:{color:n?"darkgray":"black"},children:e})})}},3832:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>r});var s=t(6540),a=t(558),i=t(4848);const r=()=>{const[e,n]=s.useState(""),[t,r]=s.useState(!1),o=(0,a.mp)((()=>(e=>new Promise((n=>{setTimeout((()=>n(`created user with name ${e} and id #1`)),1e3)})))(e)));return(0,i.jsxs)("div",{children:[(0,i.jsx)("h4",{children:"Create user"}),(0,i.jsxs)("label",{children:["name:",(0,i.jsx)("input",{onChange:e=>n(e.currentTarget.value),value:e})]}),(0,i.jsx)("button",{onClick:()=>r(!0),children:"Create user"}),t&&(0,i.jsx)(a.nS,{store:o,children:e=>(0,i.jsx)("p",{children:e})})]})}},4999:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>o});t(6540);var s=t(558),a=t(4848),i=0;const r=()=>new Promise((e=>{i+=1,setTimeout((()=>e(i)),1e3)})),o=()=>{const e=(0,s.mp)(r,{invalidation:s.Mf.pollUntil((e=>e>2),1e4),debug:!0,storeName:"polling-store"});return(0,a.jsx)(s.nS,{store:e,children:(e,n)=>n?(0,a.jsxs)("span",{children:["invalid data ",e]}):(0,a.jsx)("span",{children:e})})}},5107:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    InvalidationStrategy,\n    useRemoteData,\n    WithRemoteData,\n} from 'use-remote-data';\n\nvar i = 0;\nconst freshData = (): Promise<number> =>\n    new Promise((resolve) => {\n        i += 1;\n        setTimeout(() => resolve(i), 1000);\n    });\n\nexport const Component: React.FC = () => {\n    const store = useRemoteData(freshData, {\n        invalidation: InvalidationStrategy.pollUntil((x) => x > 2, 10000),\n        debug: true,\n        storeName: 'polling-store',\n    });\n\n    return (\n        <WithRemoteData store={store}>\n            {(num, notValid) =>\n                notValid ? <span>invalid data {num}</span> : <span>{num}</span>\n            }\n        </WithRemoteData>\n    );\n};\n"},5170:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    InvalidationStrategy,\n    RemoteDataStore,\n    useRemoteData,\n    WithRemoteData,\n} from 'use-remote-data';\n\nvar i = 0;\nconst freshData = (): Promise<number> =>\n    new Promise((resolve) => {\n        i += 1;\n        setTimeout(() => resolve(i), 1000);\n    });\n\nexport const Component: React.FC = () => {\n    const store = useRemoteData(freshData, {\n        invalidation: InvalidationStrategy.refetchAfterMillis(2000),\n    });\n\n    return (\n        <div>\n            <Child store={store} />\n            <Child store={store} />\n        </div>\n    );\n};\n\nexport const Child: React.FC<{ store: RemoteDataStore<number> }> = ({\n    store,\n}) => (\n    <WithRemoteData store={store}>\n        {(num, isInvalidated) => (\n            <p>\n                <span style={{ color: isInvalidated ? 'darkgray' : 'black' }}>\n                    {num}\n                </span>\n            </p>\n        )}\n    </WithRemoteData>\n);\n"},5525:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    InvalidationStrategy,\n    RemoteDataStore,\n    RemoteDataStores,\n    useRemoteDatas,\n    WithRemoteData,\n} from 'use-remote-data';\n\nlet is = new Map<string, number>();\n\nconst freshData = (key: string): Promise<string> =>\n    new Promise((resolve) => {\n        const num = is.get(key) || 0;\n        is.set(key, num + 1);\n        setTimeout(() => resolve(`${key}: ${num}`), 500);\n    });\n\nexport const Component: React.FC = () => {\n    // provide `freshData` function\n    const stores: RemoteDataStores<string, string> = useRemoteDatas(freshData, {\n        invalidation: InvalidationStrategy.refetchAfterMillis(1000),\n    });\n\n    const [wanted, setWanted] = React.useState('a, b,d');\n\n    const parsedWanted: readonly string[] = wanted\n        .split(',')\n        .map((s) => s.trim())\n        .filter((s) => s.length > 0);\n\n    const currentStores: readonly RemoteDataStore<string>[] =\n        stores.getMany(parsedWanted);\n\n    return (\n        <div>\n            Add/remove stores by editing the text, it's split by comma.\n            <input\n                value={wanted}\n                onChange={(e) => setWanted(e.currentTarget.value)}\n            />\n            <div style={{ display: 'flex', justifyContent: 'space-around' }}>\n                <Column rows={currentStores} />\n                <Column rows={currentStores} />\n            </div>\n        </div>\n    );\n};\n\nexport const Column: React.FC<{ rows: readonly RemoteDataStore<string>[] }> = ({\n    rows,\n}) => {\n    const renderedRows = rows.map((store, idx) => (\n        <WithRemoteData store={store} key={idx}>\n            {(value, isInvalidated) => (\n                <p>\n                    <span\n                        style={{ color: isInvalidated ? 'darkgray' : 'black' }}\n                    >\n                        {value}\n                    </span>\n                </p>\n            )}\n        </WithRemoteData>\n    ));\n    return <div>{renderedRows}</div>;\n};\n"},5550:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Child:()=>l,Component:()=>o});t(6540);var s=t(558),a=t(4848),i=0;const r=()=>new Promise((e=>{i+=1,setTimeout((()=>e(i)),1e3)})),o=()=>{const e=(0,s.mp)(r,{invalidation:s.Mf.refetchAfterMillis(2e3)});return(0,a.jsxs)("div",{children:[(0,a.jsx)(l,{store:e}),(0,a.jsx)(l,{store:e})]})},l=e=>{let{store:n}=e;return(0,a.jsx)(s.nS,{store:n,children:(e,n)=>(0,a.jsx)("p",{children:(0,a.jsx)("span",{style:{color:n?"darkgray":"black"},children:e})})})}},5588:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    InvalidationStrategy,\n    RemoteDataStore,\n    useRemoteData,\n    WithRemoteData,\n} from 'use-remote-data';\n\nvar i = 0;\nconst freshData = (): Promise<number> =>\n    new Promise((resolve) => {\n        i += 1;\n        setTimeout(() => resolve(i), 1000);\n    });\n\nvar j = 0;\nconst failSometimes = (): Promise<number> =>\n    new Promise((resolve, reject) => {\n        j += 1;\n        if (j % 10 === 0) reject(`${j} was dividable by 10`);\n        else resolve(j);\n    });\n\nexport const Component: React.FC = () => {\n    const one = useRemoteData(freshData, {\n        invalidation: InvalidationStrategy.refetchAfterMillis(1000),\n    });\n    const two = useRemoteData(failSometimes, {\n        invalidation: InvalidationStrategy.refetchAfterMillis(100),\n    });\n    return (\n        <WithRemoteData store={RemoteDataStore.all(one, two)}>\n            {([num1, num2]) => (\n                <span>\n                    {num1} - {num2}\n                </span>\n            )}\n        </WithRemoteData>\n    );\n};\n"},7879:(e,n,t)=>{"use strict";t.d(n,{A:()=>s});const s=t.p+"assets/medias/typesafe-combine-37a96b8d5a32a72484882b73e60806db.webm"},8789:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Component:()=>r});t(6540);var s=t(558),a=t(4848);function i(e,n){return void 0===n&&(n=1e3),new Promise((t=>setTimeout((()=>t(e)),n)))}const r=()=>{const e=(0,s.mp)((()=>i(1))),n=(0,s.mp)((()=>i("Hello"))),t=s.Qt.all(e,n);return(0,a.jsx)(s.nS,{store:t,children:e=>{let[n,t]=e;return(0,a.jsxs)("span",{children:[n," and ",t]})}})}},8794:(e,n,t)=>{"use strict";t.d(n,{Y:()=>o});var s=t(6289),a=t(6540),i=t(8069),r=t(4848);const o=e=>{let{snippet:n}=e;const o=t(1266)(`./${n}.tsx`).default,{Component:l}=t(250)(`./${n}`),[d,c]=a.useState(0);return(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{language:"tsx",children:o}),(0,r.jsxs)("div",{children:[(0,r.jsx)("div",{children:(0,r.jsx)(s.A,{className:"button button--secondary button--sm",onClick:()=>c(d+1),children:0===d?"Run snippet":"Run again"})}),d>0&&(0,r.jsx)("div",{style:{padding:"1em",margin:"1em",backgroundColor:"#b8e092",color:"black"},children:(0,r.jsx)(l,{},d)})]}),(0,r.jsx)("br",{})]})}},8936:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    RemoteDataStore,\n    useRemoteData,\n    WithRemoteData,\n} from 'use-remote-data';\n\nfunction produce<T>(value: T, delay: number = 1000): Promise<T> {\n    return new Promise((resolve) => setTimeout(() => resolve(value), delay));\n}\n\nexport const Component: React.FC = () => {\n    const computeOne: RemoteDataStore<number> = useRemoteData(() => produce(1));\n\n    return (\n        <WithRemoteData store={computeOne}>\n            {(num: number) => <span>{num}</span>}\n        </WithRemoteData>\n    );\n};\n"},9439:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});const s="import * as React from 'react';\nimport {\n    InvalidationStrategy,\n    useRemoteData,\n    WithRemoteData,\n} from 'use-remote-data';\n\nvar i = 0;\nconst freshData = (): Promise<number> =>\n    new Promise((resolve) => {\n        i += 1;\n        setTimeout(() => resolve(i), 1000);\n    });\n\nexport const Component: React.FC = () => {\n    const [autoRefresh, setAutoRefresh] = React.useState(true);\n    const store = useRemoteData(freshData, {\n        invalidation: autoRefresh\n            ? InvalidationStrategy.refetchAfterMillis(1000)\n            : undefined,\n    });\n\n    return (\n        <div>\n            <label>\n                Autorefresh:\n                <input\n                    type=\"checkbox\"\n                    onChange={(e) => setAutoRefresh(!autoRefresh)}\n                    checked={autoRefresh}\n                />\n            </label>\n            <br />\n            <WithRemoteData store={store}>\n                {(num, isInvalidated) => (\n                    <span\n                        style={{ color: isInvalidated ? 'darkgray' : 'black' }}\n                    >\n                        {num}\n                    </span>\n                )}\n            </WithRemoteData>\n        </div>\n    );\n};\n"},9641:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Column:()=>d,Component:()=>l});var s=t(6540),a=t(558),i=t(4848);let r=new Map;const o=e=>new Promise((n=>{const t=r.get(e)||0;r.set(e,t+1),setTimeout((()=>n(`${e}: ${t}`)),500)})),l=()=>{const e=(0,a.$o)(o,{invalidation:a.Mf.refetchAfterMillis(1e3)}),[n,t]=s.useState("a, b,d"),r=n.split(",").map((e=>e.trim())).filter((e=>e.length>0)),l=e.getMany(r);return(0,i.jsxs)("div",{children:["Add/remove stores by editing the text, it's split by comma.",(0,i.jsx)("input",{value:n,onChange:e=>t(e.currentTarget.value)}),(0,i.jsxs)("div",{style:{display:"flex",justifyContent:"space-around"},children:[(0,i.jsx)(d,{rows:l}),(0,i.jsx)(d,{rows:l})]})]})},d=e=>{let{rows:n}=e;const t=n.map(((e,n)=>(0,i.jsx)(a.nS,{store:e,children:(e,n)=>(0,i.jsx)("p",{children:(0,i.jsx)("span",{style:{color:n?"darkgray":"black"},children:e})})},n)));return(0,i.jsx)("div",{children:t})}}}]);