import { Snippet } from '../components/Snippet';
import typesafeCombine from '../../static/typesafe-combine.webm';

# Getting Started

`use-remote-data` is a small library that provides a principled, type-safe way to manage asynchronous state in your React applications.
It revolves around a **core state machine** represented by the `RemoteData` type and a corresponding
`RemoteDataStore` that orchestrates fetching,
caching, invalidation,
and retries—all while staying strongly typed.

---

## Installation

```bash
npm install use-remote-data
```

```bash
yarn add use-remote-data
```

---

## The Core State Machine

At the heart of this library is the **`RemoteData`** type.
It captures all possible states of an async request in a single union:

```ts
export type RemoteData<T> =
  | { type: 'initial' }
  | { type: 'pending' }
  | { type: 'no'; errors: ReadonlyArray<Error | unknown>; retry: () => Promise<void> }
  | { type: 'yes'; value: T }
  | { type: 'invalidated-initial'; invalidated: T }
  | { type: 'invalidated-pending'; invalidated: T };
```

This state machine allows the library to cleanly handle the life cycle of any request:

- **`initial`**: We haven’t started fetching yet (lazy load).
- **`pending`**: A request is ongoing (fetch in progress).
- **`no`**: The request failed (includes errors and a retry callback).
- **`yes`**: The request succeeded (includes the fetched value).
- **`invalidated-initial`**: We have stale data but haven’t started fetching.
- **`invalidated-pending`**: We have stale data and are fetching an update.

By modeling states explicitly, React components can branch on them in a straightforward and type-safe manner.

---

## Basic Usage

The primary entry point is the **`useRemoteData`** hook.
It takes one parameter—a function that produces a `Promise`—and returns a `RemoteDataStore<T>`.
Because we need the ability to retry, you must pass a function rather than a direct `Promise`.

- According to [React Hooks rules](https://reactjs.org/docs/hooks-rules.html), the hook must be used inside a component.
- The object returned by `useRemoteData` is our `RemoteDataStore<T>`.

<Snippet snippet="basic_usage" />

### The `<WithRemoteData>` Component

The library provides a small helper component called `WithRemoteData` for convenience. It expects two props:

1. **`store`**: The `RemoteDataStore` returned by `useRemoteData`.
2. **`render`**: A [render prop](https://reactjs.org/docs/render-props.html) that receives your successfully loaded data (along with an `isInvalidated` boolean).

Out of the box, `WithRemoteData` handles loading and error states but is visually minimal.
You can copy it directly into your codebase
or wrap it to provide custom styling and behavior for pending and failure states.

### Lazy Loading
An interesting aspect of `useRemoteData` is no data is fetched when you call `useRemoteData`.

Only when the data is rendered with `WithRemoteData` is the request initiated.
This is handy, because then you can initialize many `RemoteDataStore`s in a component high up in the hierarchy, and pass them down to children.

### Parallel vs. Sequential Fetching

When your app renders data from multiple `RemoteDataStore` instances, they will initiate their requests in parallel if the data is missing or old.

This parallel behavior ensures quicker overall loading times when you need multiple pieces of data at once.

If you need to fetch data in a specific order, you can achieve this by nesting `WithData` inside `WithData` in your JSX,
meaning that the inner won't be rendered/requested until the outer has finished.

### Data Lifetime Aligned with React Components

Because each store is created by the hook in a mounted component, data only exists as long as that component is active.
There’s no global state or context—once the component unmounts, the store is effectively garbage-collected.
This design ensures data is retained only while it’s relevant.

---

## Combining Stores

One of the library’s most powerful patterns is combining multiple requests.
If you have two or more `RemoteDataStore`s,
you can merge them into a single store that represents all requests in flight.
This is done via `RemoteDataStore.all(...)`:

Under the hood, the combined store uses the `RemoteData.all(...)` function, which:

- Returns `No` if *any* store fails. A single “retry” will only re-fetch the failing requests.
- Returns `Pending` if *any* constituent store is `Pending`.
- Returns `Yes` with a tuple of all combined values if *all* succeed.
- Manages invalidation states if any store becomes invalidated.

In a render prop, you can
[destructure](https://levelup.gitconnected.com/crazy-powerful-typescript-tuple-types-9b121e0a690c)
the results.

<Snippet snippet="combine" />

#### A Note on TypeScript Tooling

The TypeScript compiler (and IDEs) fully understands these combined stores.
You can hover over the tuple items (often with <kbd>Ctrl</kbd> or <kbd>Command</kbd>) to see precise type information.

<video autoPlay controls muted style={{maxWidth: '100%'}} src={typesafeCombine}></video>

---

## Refreshing Data (Invalidation)

Sometimes data becomes out-of-date.
supports “invalidation” through an optional `invalidation` parameter on the hook.
An **`InvalidationStrategy<T>`** is a small object that decides whether to keep data or mark it stale.
For example:

```ts
{
  invalidation: InvalidationStrategy.refetchAfterMillis(10_000);
}
```

If the data is older than 10 seconds, the store automatically transitions into one of the `invalidated-*` states.
In the `<WithRemoteData>` render prop,
you can check the second argument (`isInvalidated`)
to decide whether to let the user see old data or a loading indicator.

<Snippet snippet="invalidation" />

### Only Sometimes?

You can enable or disable invalidation dynamically by swapping the `invalidation` strategy in or out. For instance:

<Snippet snippet="invalidation_sometimes" />

---

## Sharing Data with Child Components

A common pattern is to fetch data high in your component tree and share it among multiple routes or components,
leveraging built-in caching so that each route doesn’t refetch unnecessarily.

Since `RemoteDataStore` is both *lazy* and *caching*, you can pass the same store to multiple children.
Data is fetched only once, and the results remain in memory as long as a store is in use.

<Snippet snippet="use_twice" />

### Should I Pass `RemoteDataStore<T>` or Just `T`?

There’s a subtle difference:

> *Does the child component need to render anything while data is still loading?*

- If yes, consider passing a `RemoteDataStore<T>` so the child can handle loading/failure states.
- Otherwise, if the parent already handles loading and passes down final data, just pass `T`.

---

## Handling Failure and Retries

Another defining feature of `use-remote-data` is the principled error handling and the retry
functionality.
Developers typically make an ad-hoc attempt at the former, while not many have the
discipline to also do the latter.

This example creates a `Promise` which fails every tenth time it is called.
The sometimes-failing store is combined with another store which never fails,
and you should hit *retry* a few times to see the interaction.

<Snippet snippet="handling_failure" />

---

## Dynamic Data

If you need parameterized requests—like paginated lists
or fetching multiple resource IDs—use the **`useRemoteDatas`** (plural) hook.
It returns an object with a `.get(key)` method for each distinct data slice.

```tsx
const itemsStore = useRemoteDatas(
  (page: number) => fetch(`/api/items?page=${page}`).then((res) => res.json())
);

const firstPageStore = itemsStore.get(1);
const secondPageStore = itemsStore.get(2);
```

This creates independent `RemoteDataStore` objects for each page, all managed under one `RemoteDataStores` instance.

<Snippet snippet="dynamic" />

---

## Invalidate on Dependency Change

`useRemoteData` and `useRemoteDatas` let you provide a `dependencies` array (similar to React’s `useEffect`):

```tsx
useRemoteData(() => fetchData(), {
  dependencies: [props.userId, otherValue],
});
```

When the dependency array changes, the store invalidates automatically, and `triggerUpdate()` will re-fetch if needed.
(Currently, it compares dependencies by `JSON.stringify`.)

<Snippet snippet="invalidation_dependencies" />

---

## Updates (Write Operations)

Your application might need to send data back to the server.
While `use-remote-data` focuses on read operations,
you can still integrate writes by calling out to the server in your components.
After a successful write,
call `invalidate()` or `triggerUpdate()` to refresh any store that depends on the changed data.

<Snippet snippet="create" />

---

## Conclusion

`use-remote-data` provides a comprehensive, type-safe approach to async state management in React.
It builds on a clear state machine (`RemoteData`), robust invalidation (`InvalidationStrategy`), and fully typed store composition.